<script>
/* 


This document here is simply for me to run JS code.




*/
var a; // declaring a variable
    var b = 2; // asigning a variable
    console.log(a)
    a = 7; // assigining variable
    console.log(a)
    b = a;
    
    console.log(a)

// Initialise these three variables

var a = 5;
var b = 10;
var c = "I am a ";

// Do not change code below this line

a = a + 1;
b = b + 5; 
c = c + "String"

console.log(a)
console.log(b)
console.log(c) 

// Find Length of String

// Example 

var firstNameLength = 0;
var firstName = "Ada";

firstNameLength = firstName.length;

console.log(firstNameLength)

// setup 
var lastNameLength = 0;
var lastName = "Lovelace";

lastNameLength = lastName.length;

console.log(lastNameLength)

// Bracket Notation to Find First Character in String

// Example 

var firstLetterOfFirstName = "";
var firstName = "Ada";

firstLetterOfFirstName = firstName[0];

console.log(firstLetterOfFirstName)

// Setup

var secondLetterOfLastName = "";

secondLetterOfLastName = lastName[1];

console.log(secondLetterOfLastName)

var lastLetterOfFirstName = firstName[firstName.length - 1];

console.log(lastLetterOfFirstName)

var lastLetterOfLastName = lastName[lastName.length - 1];

console.log(lastLetterOfLastName)

// Bracket Notation to Find Nth - to - Last Character in String

// Example 1

var secondLastLetterOfFirstName = firstName[firstName.length - 2];

console.log(secondLastLetterOfFirstName)

// Example 2

var thirdLastLetterOfLastName = lastName[lastName.length - 3];

console.log(thirdLastLetterOfLastName)

// Word Blanks - MadLib game

function wordBlanks(myNoun, myAdjective, myVerb, myAdverb) {
    // Empty String
    var result = "";
    result += "The " + myAdjective + " " + myNoun  + " " + myVerb + " to the store " + myAdverb;
    // Result
    return result;
}


// Change the words here to test your function

console.log(wordBlanks("dog", "big", "ran", "quickly"));
console.log(wordBlanks("dress", "furry", "skipping", "ghostly"));

// Access Array Data with Indexes 

// Example 
var ourArray = [50, 60, 70];
var ourData = ourArray[0]; // equals 50

console.log(ourData)

// Modify Array Data with Indexes

ourArray[1] = 45; // ourArray now equals [50, 45, 70]

console.log(ourArray)

// Access Multi-Dimensional Arrays with Indexes

// Setup
var myArray = [[1,2,3], [4,5,6], [7,8,9], [[10, 11, 12], 13, 14] ];

// Selecting 8
var myData = myArray[2][1];

console.log(myData)

// Selecting 11
var myData = myArray[3][0][1];

console.log(myData)

// Manipulate Arrays with push ()

// Example 
var ourArray = ["King", "Queen", "Jack"];
ourArray.push(["K", "Q", "J"]);

// ourArray now equals ["King", "Queen", "Jack", ["K", "Q", "J"] ]

console.log(ourArray)

// Manipulate Arrays with Pop

var ourArray = [1,2,3];
var removedFromOurArray = ourArray.pop();

console.log(removedFromOurArray)
console.log(ourArray)
// removedFromOurArray now equals 3 and ourArray now equals [1,2]

//Note to self: this concept here can be used in finished.

// Manipulate Arrays with shift()
/* Very similar to the pop() function but instead of removing the last
element of the array it removes the first element of the array. */

// Example

var ourArray = ["King", "Queen", "Jack"];
var removedFromOurArray = ourArray.shift(0);

// removedFromOurArray now equals "King" and ourArray now equals ["Queen", "Jack"]

console.log(removedFromOurArray)
console.log(ourArray)

// Manipulate Arrays with unshift()
/* Very similar to the push() function but instead of added an
element to the end of the  array, the unshift () the adds an element 
at the start of the array. */

// Example

var ourArray = ["King", "Queen", "Jack"];
ourArray.shift(); // ourArray now equals ["Queen", "Jack"]
ourArray.unshift("Ace"); // ourArray now equals ["Ace", Queen", "Jack"]"]

console.log(ourArray)

// Write Reusable Code with Functions

// Example

function ourReusableFunction(){
    console.log("Greetings, World");
}

ourReusableFunction();


// Passing Values to Functions with Arguments
/* Parameters are variables that act as place holders for the values
   that are to be input to a function when it is called.  */

// Example, a and b are parameters.

function ourFunctionWithArgs(a, b){
    console.log(a-b);
}
ourFunctionWithArgs(10,5); // Outputs 5
ourFunctionWithArgs(45, 5);

function functionWithArgs(a, b){
    console.log(a+b);
}

functionWithArgs(45, 5);

/* Gloabal Scope and Functions
   Scope refers to the visiblity of variables. Variables which are defined 
   outside of a function block have global scope. Global scope means they can
   be seen everywhere in your Javascript code.*/

   var myGlobal = 10;

/* The absence of the var keyword means that the variable oopsGlobal is scoped
   globally opposed to locally within the function.
*/
function fun1(){
    oopsGlobal = 5;
}

/* We are using an if statement and we are checking if the type of myGlobal
   does not equal undefined. Since we have declared myGloabal as a variable in global scope
   we expect to get the follwoing result "myGlobal" 10.
*/
function fun2(){
    var output = ""
    if (typeof myGlobal != "undefined"){
        output += " myGlobal: " + myGlobal;
    }
    if (typeof oopsGlobal != "undefined"){
        output += " oopsGlobal: " + oopsGlobal;
    }
    console.log(output);
}

fun1();
fun2();
console.log(Math.sqrt(4))
console.log(2**2)

function quadraticEqSolver(a,b,c){
    var x1 = ((-b + Math.sqrt((b**2)-(4*a*c)))/(2*a));

    var x2 = ((-b - Math.sqrt((b**2)-(4*a*c)))/(2*a));

    var result = ""

    result += "x1" + " " + "=" + " " + x1 + " and " + "x2" + " " + "=" + " " + x2
    return result
}

console.log(quadraticEqSolver(1, 9, 18));

// Understanding Undefined Value Returned from a Function

// Example

var sum = 0;

function addThree(){
    sum = sum + 3;
}
console.log(addThree())

// Assignment with a Returned Value

var changed = 0;

function change(num) {
    return (num + 5) / 3;
}
changed = change(10);

console.log(changed)

// Stand in Line

/* In computer science a cue is an abstract data structure where items are kept 
   in order. New items can be added to the back of the cue and old items are taken
   off from the front of the cue.

   Below we are going to simulate this behaviour, well at least some of the functionality
   of a cue using this nextLine function.
*/

// Example

/* In this function, we can add an item to the array that's passed in.
   Then it returns the first item on the list.
*/
function nextInLine(arr, item){
    arr.push(item)
    return arr.shift();

}

var testArr = [1, 2, 3, 4, 5];

// The JSON.stringify is just a way to change an array into a string that can be easily printed out into the console.

console.log("Before: " + JSON.stringify(testArr)); // 
console.log(nextInLine(testArr, 6));
console.log("After: " + JSON.stringify(testArr));

function trueOrFalse(wasThatTrue){
    if (wasThatTrue){
        return "Yes, that was true";
    }
    return "No, that was false";
}

console.log(trueOrFalse(false));

/* Comparison with the Equality Operator

   There are many comparison operators in JavaScript that will return a 
   Boolean of true or false. The most common is the equality operator.
   It is usually used in an if statement.
*/

//Example 

function testEqual(val){
    if (val == 12) { 
        return "Equal";
    }
    return "Not Equal";
}

console.log(testEqual(10));


/* Comparison with the Strict Equality Operator
   
   We learnt about the equality operator "==", now we will learn about the 
   strict equality operator "===". The difference between them is that "=="
   attempts to convert both values being compared to common type while the 
   strict equality operator does not do the type conversion.

   so if we look at the case of 

   3 === 3 this would evaluate to true
   3 === "3" this would evaulate to false
*/

// Example

function testStrict(val){
    if (val === 7){
        return "Equal";
    }
    return "Not Equal";
}

console.log(testStrict(7));
console.log(testStrict("7"));

// Practice Comparing Different Values

// Example

function comapareEquality(a, b){
    if (a == b){
        return "Equal";
    }
    return ("Not Equal");
}

/* The one above will allows to compare differnt types, while the one below
   will allow us to compare only those of the same type.
*/

function comapareEqualityStrict(a, b){
    if (a === b){
        return "Equal";
    }
    return ("Not Equal");
}

console.log(comapareEquality(10, "10"));
console.log(comapareEqualityStrict(10, "10"));

/* Comparison with the Inequality Operator
   
   The inequality operator is basically the oppiste of the equality operator.
   Just like the equality operator it also does type conversion.
*/

function testNotEqual(val){
    if (val != 99){
        return "Not Equal";
    }
    return "Equal";
}

console.log(testNotEqual(10)) // Not Equal

function testGreaterThan(val){
    if (val > 100){
        return "Over 10";
    }
    if (val > 10){
        return "Over 10";
    }

    return "10 or Under";
}

console.log(testGreaterThan(10))

/* Else If statements

   If you have multiple conditions that need to be addressed, you can use else
   if statements. It's a way of chaining if statements together.

   In example 1 we have three conditions. In this instance one can use the else If 
   statement. Example 2 illustrates how it would be used. See how both feature 
   the same three conditions.

*/

// Example 1 - Without Else If statement

function testElseIf_Without(val){
    if (val > 10){
        return "Greater than 10"; // condition 1
    }

    if (val < 5){
        return "Smaller than 5"; // condition 2
    }

    return "Between 5 and 10"; // condition 3
}

// Example 2 - Else If statement

function testElseIf(val){
    if (val > 10){
        return "Greater than 10"; // condition 1
    } else if (val < 5){
        return "Smaller than 5"; // condition 2
    }else {
        return "Between 5 and 10"; // condition 3
    }
}

console.log(testElseIf_Without(7)); // Between 5 and 10

console.log(testElseIf(7)); // Between 5 and 10

/* Golf code 

   In the game of golf each hole has a par which means the average number of
   strokes you're supposed to use to get the ball into the hole. So depending 
   on how far above or below par your strokes are, there's a differnt nickname.

   So in this example, we had to write a function where we pass in the par and 
   the strokes. This will return the nickname associated with those arguments.
*/

var names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!" ];

function golfScore(par, strokes){
    if (strokes == 1){
        return names[0];
    } else if (strokes <= par - 2){
        return names[1];
    } else if (strokes == par - 1){
        return names[2]
    } else if (strokes == par ){
        return names[3]
    } else if (strokes == par + 1){
        return names[4]
    } else if (strokes == par + 2){
        return names[5]
    } else if (strokes == par +3){
        return names[6]
    }   
}

console.log(golfScore(5, 4));

/* Default Option in Switch Statements

   The default option is kind of like else in an if else statement.
*/

function switchOfStuff(val) {
    var answer = "";
    switch(val){
        case "a":
            answer = "apple";
            break;

        case "b":
            answer = "bird";
            break;

        case "c":
            answer = "cat";
            break;

        default:
            answer = "stuff";
            break;
    }

    return answer;
}

console.log(switchOfStuff("c"))

/* Returning Early Pattern from Functions
   
   We have gone through examples where we returned early from the functions.

*/

function abTest(a, b) {

if (a < 0 || b < 0) {
    return undefined;  // a < 0 or b < 0
}

return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2)); // round((sqrt(a) + sqrt(b))^2)
}

console.log(abTest(2,2)); // 8
console.log(abTest(2, -2)); // undefined

var count = 0

function cc(card){
    switch(card) {
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
            count ++;
            break;
        case 10:
        case "J":
        case "Q":
        case "K":
        case "A":
            count --;
            break;
    }

    var holdbet = 'Hold'
    if (count > 0){
        holdbet = 'Bet'
    }
    return count + " " + holdbet;
}

cc(2); cc(7); cc(3); cc(2);

console.log(cc("Q"));
console.log(cc("J"));
console.log(cc(5));

function chainToSwitch(val){
    var answer = "";

    switch(val){
        case "Bob":
            answer = "Marley";
            break;
        case  42:
            answer = "The Answer";
            break;
        case 1:
            answer = "There is no #1";
            break;
        case 99:
             answer = "Missed me by this much";
             break;
        case 7:
            answer = "Ate Nine";

    }
    return answer
} 

console.log(chainToSwitch(42));

/* Using Objects for Lookups

   Objects can be thought of as a key value storage like a dictionary.
   You can use an object to lookup values.

   In the example we are looking at, we have a switch statement that 
   returns certain values. The switch statement can be replaced with an
   object and use the object for lookups instead of the switch statement.

   By creating a var lookup. Notice how it is a much shorter option to use
   than using a switch statement.

*/


// Example Switch case

function phoneticSwitch(val) {
    var result = "";

    switch(val) {
        case "alpha":
            result = "Adams";
            break;
        case "bravo":
            result = "Boston";
            break;
        case "Charlie":
            result = "Chicago";
            break;
        case "delta":
            result = "Denver";
            break;
        case "echo":
            result = "Easy";
            break;            
        case "foxtrot":
            result = "Frank";
            break;
    }
    return result;
}

// Example lookup case

function phoneticLookup(val) {
    var result = "";    

    var lookup = {
        "alpha":"Adams",
        "bravo":"Boston",
        "Charlie":"Chicago",
        "delta":"Denver",
        "echo":"Easy",
        "foxtrot":"Frank",    
    };
    result = lookup[val];

    return result;
}

console.log(phoneticSwitch("alpha"));
console.log(phoneticLookup("alpha"));

var myStorage = {
    "car": {
        "inside": {
            "glove box": "maps",
            "passenger seat": "crumbs"
        },
        "outside": {
            "trunk": "jack"
        }
    }
};

var gloveBoxContents = myStorage.car.inside["glove box"];

console.log(gloveBoxContents);

/* Accessing Nested Arrays
   
   Array bracket notation can be chnaged to access nested arrays.
   
   In the example we have an array and two objects. Each object has
   elements that are arrays.

*/

var myPlants = [
    { 
        type: "flowers",
        list:[
            "rose",
            "tulip",
            "dandelion"
        ]
    },
    {
        type: "trees",
        list:[
            "fir",
            "pine",
            "birch"
        ]   
    }
];


var secondTree = myPlants[1].list[1];

console.log(secondTree);

/* Record Collection

   This example focuses on an object, that has an ID, a property and a value.
   The aim is to create a function that can update the collection.
*/

var collection = {
    "2548": {
        "album": "Slippery When Wet",
        "artist": "Bon Jovi",
        "tracks": [
            "Let It Rock",
            "You Give Love a Bad Name"
        ]
    },
    "2568": {
        "album": "1999",
        "artist": "Prince",
        "tracks": [
            "1999",
            "Little Red Corvette"
        ]
    },
    "1245": {
        "artist": "Robert Palmer",
        "tracks": [ ]
    },
    "5439": {
        "album": "ABBA Gold",
    },
};

// Keep a copy of the collection for tests
var collectionCopy = JSON.parse(JSON.stringify(collection));

function updateRecords(id, prop, value){
    if (value === ""){
        delete collection[id][prop];
    } else if (prop === "tracks") {
        collection[id][prop] = collection[id][prop] || [];
        collection[id][prop].push(value);
    } else {
        collection[id][prop] = value;
    }

    return collection;
}

console.log(updateRecords(5439, "artist", "ABBA"));

/* Iterate with While Loops

   Loops allow you to run the same code multiple times.
   The while Loop runs while a specified condition is true
   and stops once it's no longer true.

*/

var myArray = [];

var i = 0;
while(i < 5) {
    myArray.push(i);
    i++;
}

console.log(myArray);

/* Count Backwards with a For Loop

*/

var myArray = [];

for (var i=10; i > 0; i -=2) {
    myArray.push(i);
}

console.log(myArray);

/* Iterate Through an Array with a For Loop

   It is common in JavaScript to iterate through the contents of an
   array.

*/

var ourArr = [9, 10, 11, 12];
var ourTotal = 0;

for (var i = 0; i < ourArr.length; i++) {
    ourTotal += ourArr[i];
}

console.log(ourTotal);

/* Nesting for Loops

   If you have multidimensonal or nested array, you can use nested for loops
   to access all the array elements. 

   Since we already have an i within the scope mentioned in the first for loop
   we declare j...if we had to make another it would be h.

*/ 

// Exmaple 

function multiplyAll(arr) {
    var product = 1;

    for (var i=0; i < arr.length; i++){
        for (var j=0; j < arr[i].length; j++){
            product *= arr[i][j];
        }
    }

    return product;
}
// Basically 7! 

var product = multiplyAll([[1,2], [3,4], [5,6,7]]);

console.log(product);

/* Iterate with Do...While Loops

   While loops first checks the condition before it runs any code within the loop.
   A Do while loop will always run at least one time before it will check the 
   condition.

*/

// Example 4

var myArray = [];
var i = 10;

while (i < 5) {
    myArray.push(i);
    i++;
}

console.log(myArray);

var myArray = [];
var i = 10;

do {
    myArray.push(i);
    i++;
} while (i < 5)

console.log(i, myArray);

/* Profile Lookup

   This is a coding challenge. You have an array of objects.
   Each object represents a contact.

*/

// Example

var contacts = [
    {
        "firstName": "Akira",
        "lastName": "Laine",
        "number": "0543236543",
        "likes": ["Pizza", "Coding", "Brownie Points"]
    },
    {
        "firstName": "Harry",
        "lastName": "Potter",
        "number": "0994372684",
        "likes": ["Hogwarts", "Magic", "Cho"]
    },
    {
        "firstName": "Sherlock",
        "lastName": "Holmes",
        "number": "0487345643",
        "likes": ["Intriguing cases", "Violin"]
    },
    {
        "firstName": "Kristian",
        "lastName": "Vos",
        "number": "unknown",
        "likes": ["JavaScript", "Gaming", "Foxes"]
    },
    {
        "firstName": "Luffy",
        "lastName": "Monkey",
        "number": "No Den Den Mushi",
        "likes": ["meat", "nakama", "One piece"]
    }
    
]
function lookUpProfile(name, prop) {

    for (var i = 0; i < contacts.length; i++){
        if(contacts[i].firstName === name){
            return contacts[i][prop] || "No such property";
        }
    }
    return "No such contact";
}

var data = lookUpProfile("Luffy", "one");

console.log(data);

/* Generate Random Fractions

   There is a simple way to create a random decimal in JavaScript.

*/

function randomFraction() {

return Math.random();
}

console.log(randomFraction())

/* Generate Random Whole Number

   We need to adapt the inequality from before.

   (0 =< x < 1)*20 = 0 =< x < 20

*/

// Example

var randomNumberBewteen0and19 = Math.floor(Math.random() * 20);

function randomWholeNum() {

    return randomNumberBewteen0and19;

}

// or

function randomWholeNumber() {

    return Math.floor(Math.random() *30);
}

console.log(randomWholeNum());

console.log(randomWholeNumber());

/* Generate Random Whole Numbers within a Range

   

*/


function ourRandomRange(ourMin, ourMax) {

return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;
}

console.log(ourRandomRange(1,9));

/* Use the parseInt Function

   It takes a string and returns an integer. This will be useful for calculations
   where we want to perform calculations.

   If the string cannot be converted into an integer in returns in NaN
   for Not a Number.

*/

// Example

function convertToInteger(str) {
    return parseInt(str);
}

console.log(convertToInteger("10001"));

/* Use the parseInt Function with a Radix

   The parseInt function can also be used with a radix. 
   The radix specifies the base of the number in the string.

   base 2 is binary. 
   base 10 is what we normally use in day to day life it is also 
   the default option.
   
*/

function convertToInteger(str) {
    return parseInt(str, 2)
}

console.log(convertToInteger("10011"));

/* Compare Scopes of the var and let keywords

   Another major difference between the var and let keywords is that when you
   declare a variable with var, it is declared globally or locallly if declared
   inside a function. 

   However, let - the scope of let is limited to the block statement or expression
   that it was declared in.

   See example 1, notice how the output is:
   
   Block scope i is: block scope

   Function scope i is: block scope

   Meanwhile example 2 will be:

   Block scope i is: block scope

   Function scope i is: function scope

   Note: A block is just anything inside these squiggly braces here.

   So in our examples we have two blocks, so when we use let to declare
   our variables, it accounts for the outer block which is for the function
   and the inner block of the If statement. 

*/

// Example 1
function checkScope() {
    "use strict";
    var i = "function scope";
    if (true) {
        i = "block scope";
        console.log("Block scope i is:", i);
    }
    console.log("Function scope i is:", i);
    return i;
}

checkScope();

// Example 2 

function checkScope() {
    "use strict";
    let i = "function scope";
    if (true) {
        let i = "block scope";

        console.log("Block scope i is:", i);
    }
    console.log("Function scope i is:", i);
    return i;
}

checkScope();

/* Declare a Read-Only Variable with the const Keyword

   const is another way to declare a variable. It has all the features
   of let but it's also read-only. You cannot reassign a const.

*/

function printManyTimes(str) {
    "use strict";

    var sentence = str + " is cool!";

    sentence = str + " is amazing!";

    for(var i = 0; i < str.length; i+=2) {
        console.log(sentence);
    }
}

printManyTimes("OnePiece");

function printManyTimes(str) {
    "use strict";

    const SENTENCE = str + " is cool!";

    for(let i = 0; i < str.length; i+=2) {
        console.log(SENTENCE);
    }
}

printManyTimes("OnePiece");

/* Mutate an Array Declared with const

   While you cannot reassign a variable that was declared with const,
   however, you can mutate an array.

*/ 

const s = [5, 7, 2];

function editInPlace() {
    "use strict";

    // s = [2, 5, 7]; This can't work because I can't reassign the variable.
    // However using Bracket notation I can mutate the array.
    s[0] = 2;
    s[1] = 6;
    s[2] = 7;

}
editInPlace();

console.log(s);

/* Prevent Object Mutation

   In the previous example, we saw how a const declaration alone doesn't really
   proctect your data from mutation.

   If you have an object or an array, you can still mutate it even it's declared with
   const.

   There is something called object.freeze that will prevent data mutation.

*/

function freezeObj() {
    "use strict";
    const MATH_CONSTANTS ={
        PI: 3.14
    };

    Object.freeze(MATH_CONSTANTS);
    try {
        MATH_CONSTANTS.PI =99;
    } catch( ex ) {
        console.log(ex);
    }
    return MATH_CONSTANTS.PI;

}

const PI =freezeObj();

/* Write Higher Order Arrow Functions
   
   Arrow functions work really well with higher order functions such as
   map, filter, and reduce. All we need to know about these higher order
   functions for now is that they take functions as arguments for processing
   collections of data.

   Whenever one function takes another function as an argument, that is suitable
   time for an arrow function.

   In the previous example we saw that when we had two arguments we put parenthesis
   around them, however if we have a single argument, you don't need to follow that
   format. Look at the example below if you are confused.

   Note: Number.isInteger() is a built-in function in JavaScript 
   that checks if a value is an integer. It returns true if the 
   value is an integer and false if not.

*/

// Example 1

const realNumberArray = [4, 5.6, -9.8, 3.14, 42, 6, 8.34, -2];

const squareList = (arr) => {
    const squaredIntegers = arr.filter(num => Number.isInteger(num) && num > 0).map(x => x * x);
    return squaredIntegers;
};

const squaredIntegers = squareList(realNumberArray);
console.log(squaredIntegers);

/* Write Higher Order Arrow Functions

   In order to create more flexible functions you can use default parameters.
   The defualt parameter kicks in when the argument is not specified or is 
   undefined.

   In the example covered below, we have set number and value as our parameters.
   In the case that we have no value arg passed in, we take the defualt value of
   1. 

*/

const increment = (function() {
    return function increment(number, value = 1){
        return number + value;
    };
})();

console.log(increment(5, 2));
console.log(increment(5));

/* Use the Rest Operator with Function Parameters

   The rest operator allows you to create a function that takes a variable number 
   of arguments. The rest operator is three dots.

   The function below is taking three arguments x, y, and z and it's summing them.
   So it's converting these x, y, and z into an array called args; and then reducing
   them.

   So the problem here is that this is only limited to 3 numbers as the array args.
   The option with the rest operator, means we can mae an array that we can pass 
   everything into a single array called args. Allow us to have any number of arguments
   now as the array is exapansive.

*/

// Example without

const sum1 = (function () {
    return function sum1 (x, y, z) {
        const args = [x, y, z]
        return args.reduce((a, b) => a + b, 0);
    };
}) ();

console.log(sum1(1, 2, 3));

// Example with the rest operator
const sum2 = (function () {
    return function sum2 (...args) {
        return args.reduce((a, b) => a + b, 0);
    };
}) ();

console.log(sum2(1, 2, 3, 4, 5));

/* Use the Spread Operator to Evaluate Arrays In-Place

   The spread operator looks just like the rest operator.
   But it expands an already existing array or spreads out an array.

   Below, we have two examples, that illustrate the effect
   of using the spread operator. 

   One should understand the example without the spread operator
   equates the two different arrays. Meanwhile in the second example
   we see that the spread operator is used to transfer all the elements
   of the arr1 into arr2, making it a direct copy.

   Note: You can only use it in an argument to a function or in an array
   literal.

   Array literal: An array literal is a way of creating a new array in 
   JavaScript by specifying its elements in square brackets, separated by 
   commas.

*/

// Example 1
const arr1 = ['Luffy', 'Zoro', 'Nami', 'Usopp', 'Sanji', 'Chopper', 'Robin', 'Franky', 'Brook'];
let arr2;
(function(){
    arr2 = arr1;
    arr1[0] = 'potato'
})();

console.log(arr2);

// Example 2
const arr3 = ['Luffy', 'Zoro', 'Nami', 'Usopp', 'Sanji', 'Chopper', 'Robin', 'Franky', 'Brook'];
let arr4;
(function(){
    arr4 = [...arr3];
    arr3[0] = 'One Piece'
})();

console.log(arr4);

// Another example of destructuring 
const AVG_TEMPERATURES = { 
    today: 77.5,
    tomorrow: 79
};

function getTempOftmrw(avgTemperatures){
    "use strict"

    // Get the field of tomorrow and assign it to the tempOfTomorrow variable.

    const{ tomorrow : tempOfTomorrow} = avgTemperatures
    return tempOfTomorrow;
}

console.log(getTempOftmrw(AVG_TEMPERATURES));

/* Destructuring Assignment with Nested Objects

   Destructuring assignment can also be used to assign variables from nested objects.

   In the example below we destructured two times. The intial curly brackets gets 
   tomorrow, then the nested curly bracket gets the max option.

*/

const Local_Forecast = {
    today: {min: 72, max: 83},
    tomorrow: { min: 73.3, max: 84.6}
};

function getMaxOfTmrw(forecast) {
    "use strict";

    const { tomorrow : { max: maxOfTomorrow }} = forecast;

    return maxOfTomorrow;
}

console.log(getMaxOfTmrw(Local_Forecast));

/* Use Destructuring Assignement to assign variables from arrays

   In the example below we have an array where we are assigning 
   z and x to the first two numbers of the array, 1, and 2.

   The difference between destructuring in an array from an object
   is that you can't specify which element from the array to go into
   the variable, it just goes in order.

   You can use the destructuring of arrays to switch the places of 
   variables.

*/
// Example 1

const [z, x, , y] = [1, 2, 3, 4, 5, 6];
console.log(z, x, y);

// Example 2
var a = 8, b = 6;

(() => {
    "use strict";

    [a, b] = [b, a];

}) ();

console.log(a);
console.log(b);

/* Use Destructuring Assignment with the Rest Operator

   The method of destructuring assignment in conjuction with the rest operator
   to reassign array elements.
*/

const source =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
function removeFirstTwo(list) {

    const [ , , ...arr] = list;
    
    return arr;
}

var arr = removeFirstTwo(source);
console.log(arr);
console.log(source);

/* Use Destructuring Assignment to Pass an Object as a Function's Parameters

   You can use the destructuring assignment to pass an object as a function's 
   parameter.

   In example 1 below we have this half function and it gets the stats arguments.
   The variable stats is an object, so with how we have set up example 1, it means
   we have to pass through all the stat variables before it works.

   In example 2 we use destructuring to make this process more effiecent. So, now 
   when the stats gets passed in it's destructured into the max and min variables.

   So the max and min from the function gets passed in. Although the two examples 
   give us the same results, the second example only passes in what we want. This 
   aspect of destructuring is why we commonly use this method in API calls, in the 
   case of getting information from an Ajax request or an API request, it will often
   have a lot more information than what you need. This is when you use destructuring 
   to get it down to what we actually want to work with.
   
*/

// Example 1
var stats = {
    max: 56.78,
    standard_deviation: 4.34,
    median: 34.54,
    mode: 23.87,
    min: -0.75,
    average: 35.85
};

var half = (function () {

    return function half(stats) {
        return (stats.max + stats.min) / 2.0;
    };

}) ();

console.log(stats);
console.log(half(stats));

// Example 2
var stats = {
    max: 56.78,
    standard_deviation: 4.34,
    median: 34.54,
    mode: 23.87,
    min: -0.75,
    average: 35.85
};

var half = (function () {

    return function half({max, min}) {
        return (max + min) / 2.0;
    };

}) ();

console.log(stats);
console.log(half(stats));

/* Create Strings using Template Literals

   Template literals are a special type of string that makes creating complex strings easier.
   You make them with using a backticks instead of quotation marks.

   Advantages:

   -Can make multiline strings
   -You can add single or double quotation marks within the string, without the need to escape them.
   -You can put variables right in the string.
*/

const person = {
    name: "Monkey D. Luffy",
    age: 19
};

// Template literal with multi-line and string interpolation
const greeting = `Hello, my name is ${person.name}!
I am ${person.age} years old.`;

console.log(greeting);
/**Coding Challenge
 * We have a function called makeList and we want to create a list based on the
 * array that's passed in. So when we call makeList, we pass result.failure.
 * 
 * makeList(result.failure) should return:
 * 
 * [ `<li class="text-warning">no-var</li>`,
 *   `<li class="text-warning">var-on-top</li>`,
 *   `<li class="text-warning">linebreak</li>` ]
 * 
 * Each element in the array is a template literal that has some HTML in it.
 * 
 * The `resultDisplayArray` was initially `null`, so when we wanted to push 
 * elements into the `resultDisplayArray` using the push method, we would encounter
 * an error. In order to fix this I dedcided to intialise `resultDisplayArray` as an 
 * empty array `[]` instead of `null`.
 * 
 */

 const result = {
    success: ["max-length", "no-amd", "prefer-arrow-functions"],
    failure: ["no-var", "var-on-top", "linebreak"],
    skipped: ["id-blacklist", "no-dup-keys"]
};

function makeList(arr) {
    const resultDisplayArray = [];
    for (let i = 0; i < arr.length; i++) {
        resultDisplayArray.push(`<li class="text-warning">${arr[i]}</li>`)
    }

    return resultDisplayArray;
}

const resultDisplayArray = makeList(result.failure);
console.log(resultDisplayArray);

/** Write Concise Object Literal Declarations using Simple Fields
 * 
 * ES6 added some nice support for easily defining object literals.
 * 
 * In example 1 the `createPerson` function takes in `name`, `age`, and
 * `gender` as parameters and returns an object literal. The properties of
 * the object (`name`, `age`, `gender`) are assigned values from the function
 * parameters. 
 * 
 * ES6 you can use the consise syntax to simplify the code. SO in example 2
 * the `createPerson` function uses arrow function syntax and immediately returns
 * object literal. The properties of the object (`name`, `age`, `gender`) are
 * assigned values from the function parameters using the concise syntax. This
 * syntax allows you to directly use the parameter names as property names without 
 * repeating them.
 */

// Example 1
var createPerson = (name, age, gender) => {

return {
    name: name,
    age: age,
    gender: gender
};
};

console.log(createPerson("Sanji Vinsmoke", 21, "male"));

// Example 2
var createPerson = (name, age, gender) => ({name, age, gender});

console.log(createPerson("Rikuo Nura", 13, "male"));

    /** Write Concise Declarative Functions 
     * 
     * An object can contain a function.
     */

// Example 1
var bicycle = {
    gear: 2,
    setGear: function(newGear) {
        "use strict";
        this.gear = newGear;
    }
};

bicycle.setGear(3);
console.log(bicycle.gear);


// Example 2

var bicycle = {
    gear: 2,
    setGear (newGear) {
        "use strict";
        this.gear = newGear;
    }
};

bicycle.setGear(3);
console.log(bicycle.gear);

/**Use class Syntax to Define a COnstructor Function
 * 
 * ES6 provides a syntax to create object s using the class keyword.
 * 
 * Example 1 is the old way of creating an object where we instantiate an object 
 * using the `new` keyword. We're instantiating the SpaceShuttle object.
 * The constructor function takes a parameter `targetPlanet` and assigns it to 
 * the `targetPlanet` property of the object being created. The `new` keyword is
 * used to instantiate an instance of the `SpaceShuttle` object, with `Jupiter` being
 * passed as the `targetPlanet` argument. The resulting object is
 * assinged to the variable `zeus`, and accessing `zeus.targetPlanet` will log 
 * `'Jupiter'` to the console. 
 * 
 * In example 2 the class syntax replaces the constructor function creation. The class
 * has a constructor method that takes a `Fruit` parameter and assigns it to the 
 * `Fruit` property of the object. To create an instance of the `devilFruit` 
 * class, the `new` keyword is used with the class name, and the `Fruit` argument 
 * is passed.
 * 
 * In my opioion, the class syntax is more intuitive way of defining and creating objects 
 * when compared to the traditional way.
 */

// Example 1

var SpaceShuttle = function(targetPlanet) {
    this.targetPlanet = targetPlanet;
}

var zeus = new SpaceShuttle('Jupiter');

console.log(zeus.targetPlanet);

// Example 2

class devilFruits {
    constructor(Fruit){
        this.Fruit = Fruit;
    }
}

var nika = new devilFruits('Gum Gum no Mi');

console.log(nika.Fruit);

/** Example 3
 * 
 */

function onePiece() {
    class DevilFruits {
        constructor(name){
            this.name = name;
        }
    }
    return DevilFruits;
}

const DevilFruits = onePiece();
const gumgumnomi = new DevilFruits(`gum gum no mi`);
console.log(gumgumnomi.name);
</script>